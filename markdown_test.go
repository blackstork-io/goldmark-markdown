package markdown

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/sergi/go-diff/diffmatchpatch"
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/extension"
	"github.com/yuin/goldmark/renderer/html"
	"github.com/yuin/goldmark/util"

	"github.com/blackstork-io/goldmark-markdown/pkg/mdexamples"
)

func roundtrip(t testing.TB, source, expectedHTMLOverride []byte) {
	t.Helper()
	if !bytes.HasSuffix(source, []byte("\n")) {
		source = append(source, '\n')
	}
	mdToHtml := goldmark.New(
		goldmark.WithExtensions(
			extension.Table,
			extension.Strikethrough,
			extension.TaskList,
		),
		goldmark.WithRendererOptions(html.WithUnsafe()),
	)

	mdToMd := goldmark.New(
		goldmark.WithParser(mdToHtml.Parser()),
		goldmark.WithExtensions(NewRenderer()),
	)

	expectedHtmlBuf := &bytes.Buffer{}
	err := mdToHtml.Convert(source, expectedHtmlBuf)
	if err != nil {
		t.Fatalf("convert to html: %v", err)
	}
	expectedHtml := expectedHtmlBuf.Bytes()
	if expectedHTMLOverride != nil {
		expectedHtml = expectedHTMLOverride
	}

	generatedMarkdownBuf := &bytes.Buffer{}
	err = mdToMd.Convert(source, generatedMarkdownBuf)
	if err != nil {
		t.Fatalf("convert to markdown: %v", err)
	}
	generatedMarkdown := generatedMarkdownBuf.Bytes()
	resultingHtmlBuf := &bytes.Buffer{}
	err = mdToHtml.Convert(generatedMarkdown, resultingHtmlBuf)
	if err != nil {
		t.Fatalf("convert generated markdown to html: %v", err)
	}
	resultingHtml := resultingHtmlBuf.Bytes()

	if !bytes.Equal(expectedHtml, resultingHtml) {
		t.Errorf("generated markdown differs")
		if len(expectedHtml) < 200 {
			t.Logf("---------- original -----------\n%s\n\n", util.VisualizeSpaces(source))
			t.Logf("---------- roundtrip ----------\n%s\n\n", util.VisualizeSpaces(generatedMarkdown))
			t.Logf("---------- original HTML-------\n%s\n\n", expectedHtml)
			t.Logf("---------- roundtrip HTML------\n%s\n\n", resultingHtml)
		} else {
			// dmp := diffmatchpatch.New()
			// diffs := dmp.DiffMain(string(util.VisualizeSpaces(source)), string(util.VisualizeSpaces(generatedMarkdown)), false)
			// t.Logf("---------- md diff ------------\n%s\n\n", dmp.DiffPrettyText(diffs))
			dmp := diffmatchpatch.New()
			diffs := dmp.DiffMain(string(expectedHtml), string(resultingHtml), true)
			t.Logf("---------- HTML diff ----------\n%s\n\n", dmp.DiffPrettyText(diffs))
		}
	}
}

func TestSpecExamplesRoundtrip(t *testing.T) {
	for _, exFile := range mdexamples.ReadAllSpecExamples() {
		for _, ex := range exFile.Examples {
			t.Run(fmt.Sprintf("%s/%d", exFile.Name, ex.ID), func(t *testing.T) {
				t.Parallel()
				t.Logf("URL: %s", ex.Link)
				roundtrip(t, ex.Markdown, nil)
			})
		}
	}
}

func TestDocumentsRoundtrip(t *testing.T) {
	for _, ex := range mdexamples.ReadAllDocumentExamples() {
		t.Run(ex.Name, func(t *testing.T) {
			t.Parallel()
			if ex.Name == "definitions.md" {
				// we don't support definitions, so definition on a new line is rendered as an empty block.
				t.SkipNow()
			}
			if ex.Name == "text_below_table.md" {
				// TestTextBelowTable takes care of this test
				t.SkipNow()
			}
			roundtrip(t, ex.Data, nil)
		})
	}
}

func FuzzRenderer(f *testing.F) {
	for _, exFile := range mdexamples.ReadAllSpecExamples() {
		for _, ex := range exFile.Examples {
			f.Add(ex.Markdown)
		}
	}
	f.Fuzz(func(t *testing.T, data []byte) {
		roundtrip(t, data, nil)
	})
}

func TestFuzzFindings(t *testing.T) {
	t.Skip("Known and accepted failures in empahsis parsing")
	cases := [...][]byte{
		[]byte("* F***00000*000*00000"), // simplified to:
		[]byte("***a*b*c"),
		[]byte("_______00000000000_____00_0_!_000__ 000"), // simplified to:
		[]byte("___0_!_0__"),
	}
	for _, data := range cases {
		roundtrip(t, data, nil)
	}
}

func TestTextBelowTable(t *testing.T) {
	// For some reason if the cell is missing it would be generated by goldmark HTML without
	// alignment attribute.
	// Our parser will generate an empty cell in place of the missing cell, and the alignment
	// would be applied to it, so the difference is the `style="text-align:center"` in the last td.

	roundtrip(
		t,
		mdexamples.ReadDocumentExample("text_below_table.md").Data,
		[]byte(`<table>
<thead>
<tr>
<th style="text-align:left">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:center">d</td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
`))
}
